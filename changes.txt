 unsigned int t = myTurn();
 
	sqlite3 * db = model->smpDB ;
	char* zErrMsg = nullptr;
	// Error message in case
	
	auto sqlBuff = newChars(200);
	// start for the transaction
	sqlite3_exec(db, "BEGIN TRANSACTION", NULL, NULL, &zErrMsg);
	for (int vt = 0; vt < tpvArray.size(); vt++)
	{
		// initiate the database 
		auto an = ((const SMPActor*)(model->actrs[vt]));
	 
		// prepare the sql statement to insert
		sprintf(sqlBuff,	
			"INSERT INTO ProbTPVict (Scenario, Turn_t, Est_h,Init_i,ThrdP_k,Rcvr_j,Prob) VALUES ('%s', ?1, ?2, ?3, ?4, ?5, ?6)",
			model->getScenarioName().c_str());
		const char* insStr = sqlBuff;
		sqlite3_stmt *insStmt;
		sqlite3_prepare_v2(db, insStr, strlen(insStr), &insStmt, NULL);
	
		int rslt = 0;
		rslt = sqlite3_bind_int(insStmt, 1, t);
		assert(SQLITE_OK == rslt);
		rslt = sqlite3_bind_int(insStmt, 2, h);
		assert(SQLITE_OK == rslt);
		rslt = sqlite3_bind_int(insStmt, 3, i);
		assert(SQLITE_OK == rslt);
		rslt = sqlite3_bind_int(insStmt, 4, vt);
		assert(SQLITE_OK == rslt);
		rslt = sqlite3_bind_int(insStmt, 5, j);
		assert(SQLITE_OK == rslt);
		rslt = sqlite3_bind_double(insStmt, 6, tpvArray[vt]);
		assert(SQLITE_OK == rslt);
		rslt = sqlite3_step(insStmt);
		assert(SQLITE_DONE == rslt);
		sqlite3_clear_bindings(insStmt);
		assert(SQLITE_DONE == rslt);
		rslt = sqlite3_reset(insStmt);
		assert(SQLITE_OK == rslt);
	}
	  
    const double phij = chij / (chij + chji); // ProbVict, for i
    const double phji = chji / (chij + chji);  

    const double euVict = uhkij;  // UtilVict
    const double euCntst = phij*uhkij + phji*uhkji; // UtilContest,
    const double euChlg = (1 - sj)*euVict + sj*euCntst; // UtilChlg 
    const double duChlg = euChlg - euSQ; //  delta-util of challenge versus status-quo
    
    // do SQLite to update all tables here
    // printf ("SMPState::probEduChlg(%2i, %2i, %2i, %i2) = %+6.4f - %+6.4f = %+6.4f\n", h, k, i, j, euCh, euSQ, euChlg);
    auto rslt = tuple<double, double>(phij, duChlg);

	//Util Charge database record insertion
	memset(sqlBuff, '\0', 200);
	sprintf(sqlBuff,
		"INSERT INTO UtilChlg (Scenario, Turn_t, Est_h,Aff_k,Init_i,Rcvr_j,Util) VALUES ('%s',%d,%d,%d,%d,%d,%f)",
		model->getScenarioName().c_str(), t, h, k, i, j, euChlg);
	sqlite3_exec(db, sqlBuff, NULL, NULL, &zErrMsg);

	//ProbVict database record insertion
	memset(sqlBuff, '\0', 200);
	sprintf(sqlBuff,
		"INSERT INTO ProbVict (Scenario, Turn_t, Est_h,Init_i,Rcvr_j,Prob) VALUES ('%s',%d,%d,%d,%d,%f)",
		model->getScenarioName().c_str(), t, h, i, j, phij);
	sqlite3_exec(db, sqlBuff, NULL, NULL, &zErrMsg);

	//UtilContest database record insertion
	memset(sqlBuff, '\0', 200);
	sprintf(sqlBuff,
		"INSERT INTO UtilContest (Scenario, Turn_t, Est_h,Aff_k,Init_i,Rcvr_j,Util) VALUES ('%s',%d,%d,%d,%d,%d,%f)",
		model->getScenarioName().c_str(), t, h, k, i, j, euCntst);
	sqlite3_exec(db, sqlBuff, NULL, NULL, &zErrMsg);

	//UtilSQ database record insertion
	memset(sqlBuff, '\0', 200);
	sprintf(sqlBuff,
		"INSERT INTO UtilSQ (Scenario, Turn_t, Est_h, Aff_k,Init_i,Rcvr_j, Util) VALUES ('%s',%d,%d,%d,%d,%d,%f)",
		model->getScenarioName().c_str(), t, h, k, i,j,euSQ);
	sqlite3_exec(db, sqlBuff, NULL, NULL, &zErrMsg);

	//UtilVict database record insertion
	memset(sqlBuff, '\0', 200);
	sprintf(sqlBuff,
		"INSERT INTO UtilVict (Scenario, Turn_t, Est_h,Aff_k,Init_i,Rcvr_j,Util) VALUES ('%s',%d,%d,%d,%d,%d,%f)",
		model->getScenarioName().c_str(), t, h, k, i, j, uhkij);
	sqlite3_exec(db, sqlBuff, NULL, NULL, &zErrMsg);

	sqlite3_exec(db, "END TRANSACTION", NULL, NULL, &zErrMsg);
	printf("Stored SQL for turn %u of all estimators, actors, and positions \n", t);

	delete sqlBuff;
	sqlBuff = nullptr;